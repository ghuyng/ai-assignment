#!/usr/bin/env python3

import importlib


def uniform_crossover(candidates: List[Grid]) -> List[Grid]:
    N = len(candidates[0].data)
    children = []
    while candidates != []:
        child0 = candidates[0]
        child1 = candidates[1]
        for i in range(random_generator.integers(N)):
            point = random_generator.integers(N)
            child0.data[point], child1.data[point] = (
                child1.data[point],
                child0.data[point],
            )
        candidates = candidates[2:]
        children += [child0, child1]
    return children


def one_point_crossover(
    candidates: List[Grid], children: List[Grid] = []
) -> List[Grid]:
    """Perform "one_point_crossover" step for each pair in candidates.
    Return the accumulated children."""
    if candidates == []:
        return children
    else:
        N = len(candidates[0].data)
        # Identify the line to one_point_crossover
        point = random_generator.integers(1, N - 1)
        # Crossover: split at `point`, swap [0,point) and [point,N)
        # normal List concatenation does not work on numpy matrices
        child0 = Grid(
            np.concatenate((candidates[0].data[0:point], candidates[1].data[point:N]))
        )
        child1 = Grid(
            np.concatenate((candidates[1].data[0:point], candidates[0].data[point:N]))
        )
        return one_point_crossover(candidates[2:], children + [child0, child1])


def get_sub_grids(mat: List[List[int]]) -> List[List[int]]:
    """Return N sub squared grids from NxN grid."""
    N = len(mat)
    sqrt_N = int(np.sqrt(N))
    sub_grids_as_Lists = [[] for _ in range(N)]
    for row in range(N):
        for col in range(N):
            sub_grids_as_Lists[sub_grid_id(row, col, sqrt_N)].append(mat[row][col])
    return sub_grids_as_Lists
